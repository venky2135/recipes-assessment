package com.securin.recipes.service;

import com.securin.recipes.dto.RecipeDto;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
public class RecipeService {

    private final EntityManager em;

    public RecipeService(EntityManager em) {
        this.em = em;
    }

    public Map<String, Object> listRecipes(int page, int limit) {
        int offset = (page - 1) * limit;

        Query countQ = em.createNativeQuery("SELECT COUNT(*) FROM recipes");
        Number total = ((Number) countQ.getSingleResult());

        Query q = em.createNativeQuery(
                "SELECT * FROM recipes ORDER BY rating DESC, id ASC LIMIT :limit OFFSET :offset",
                "RecipeMapping");
        q.setParameter("limit", limit);
        q.setParameter("offset", offset);

        @SuppressWarnings("unchecked")
        List<RecipeDto> data = q.getResultList();

        Map<String, Object> res = new HashMap<>();
        res.put("page", page);
        res.put("limit", limit);
        res.put("total", total.longValue());
        res.put("data", data);
        return res;
    }

    public Map<String, Object> searchRecipes(Map<String, String> params) {
        StringBuilder sql = new StringBuilder("SELECT * FROM recipes WHERE 1=1 ");
        Map<String, Object> queryParams = new HashMap<>();

        if (params.containsKey("title")) {
            sql.append("AND LOWER(title) LIKE :title ");
            queryParams.put("title", "%" + params.get("title").toLowerCase() + "%");
        }

        if (params.containsKey("cuisine")) {
            sql.append("AND cuisine = :cuisine ");
            queryParams.put("cuisine", params.get("cuisine"));
        }

        if (params.containsKey("total_time")) {
            OpValue opv = parseOpValue(params.get("total_time"));
            sql.append("AND total_time ").append(opv.op).append(" :total_time ");
            queryParams.put("total_time", opv.value);
        }

        if (params.containsKey("rating")) {
            OpValue opv = parseOpValue(params.get("rating"));
            sql.append("AND rating ").append(opv.op).append(" :rating ");
            queryParams.put("rating", opv.value);
        }

        if (params.containsKey("calories")) {
            OpValue opv = parseOpValue(params.get("calories"));
            sql.append("AND CAST(NULLIF(SUBSTRING_INDEX(JSON_UNQUOTE(JSON_EXTRACT(nutrients, '$.calories')), ' ', 1), '') AS DECIMAL(10,2)) ")
                    .append(opv.op).append(" :calories ");
            queryParams.put("calories", opv.value);
        }

        sql.append("ORDER BY rating DESC, id ASC ");

        int limit = 100;
        if (params.containsKey("limit")) {
            try {
                limit = Math.min(1000, Integer.parseInt(params.get("limit")));
            } catch (NumberFormatException ignored) {}
        }
        sql.append("LIMIT :limit");

        Query q = em.createNativeQuery(sql.toString(), "RecipeMapping");
        for (Map.Entry<String, Object> e : queryParams.entrySet()) {
            q.setParameter(e.getKey(), e.getValue());
        }
        q.setParameter("limit", limit);

        @SuppressWarnings("unchecked")
        List<RecipeDto> data = q.getResultList();

        return Map.of("data", data);
    }

    private static class OpValue {
        String op;
        Number value;
        OpValue(String op, Number value) { this.op = op; this.value = value; }
    }

    private static final Pattern OPVAL = Pattern.compile("^(<=|>=|=|<|>)(\\d+(?:\\.\\d+)?)$");

    private OpValue parseOpValue(String expr) {
        Matcher m = OPVAL.matcher(expr.trim());
        if (!m.matches()) throw new IllegalArgumentException("Invalid filter value: " + expr);
        String op = m.group(1);
        String valStr = m.group(2);
        if (valStr.contains(".")) {
            return new OpValue(op, Double.parseDouble(valStr));
        } else {
            return new OpValue(op, Integer.parseInt(valStr));
        }
    }
}
