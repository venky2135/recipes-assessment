package com.securin.recipes.service;

import com.securin.recipes.entity.Recipe;
import com.securin.recipes.repository.RecipeRepository;
import jakarta.persistence.criteria.Expression;
import jakarta.persistence.criteria.Root;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.CriteriaQuery;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class RecipeService {
    private final RecipeRepository recipeRepository;

    public Page<Recipe> findAllPaginatedAndSorted(int page, int limit) {
        PageRequest pageable = PageRequest.of(page - 1, limit, Sort.by("rating").descending());
        return recipeRepository.findAll(pageable);
    }

    public Page<Recipe> searchRecipes(Map<String, String> filters) {
        Specification<Recipe> spec = Specification.where(null);

        // Title filter (partial match)
        if (filters.containsKey("title")) {
            String title = filters.get("title");
            spec = spec.and((root, query, cb) -> cb.like(root.get("title"), "%" + title + "%"));
        }

        // Cuisine filter (exact match)
        if (filters.containsKey("cuisine")) {
            String cuisine = filters.get("cuisine");
            spec = spec.and((root, query, cb) -> cb.equal(root.get("cuisine"), cuisine));
        }

        // Rating, Total Time, and Calories filters
        spec = spec.and(addNumericFilter(filters, "rating", "rating"));
        spec = spec.and(addNumericFilter(filters, "total_time", "total_time"));
        spec = spec.and(addNumericFilter(filters, "calories", "nutrients->>calories"));

        return recipeRepository.findAll(spec, PageRequest.of(0, 500)); // Search API returns a list, so we can use a large limit
    }

    private Specification<Recipe> addNumericFilter(Map<String, String> filters, String param, String col) {
        return (root, query, cb) -> {
            String filterVal = filters.get(param);
            if (filterVal == null || filterVal.isEmpty()) {
                return null;
            }
            
            String op = filterVal.substring(0, 2);
            double val = Double.parseDouble(filterVal.substring(2));

            Expression<String> expression;
            if (col.startsWith("nutrients->>")) {
                expression = cb.function("JSON_VALUE", String.class, root.get("nutrients"), cb.literal("$." + col.split("->>")[1]));
            } else {
                expression = root.get(col);
            }
            
            Expression<Double> numericExpression = cb.function("CAST", Double.class, expression.as(String.class));

            switch (op) {
                case ">=":
                    return cb.greaterThanOrEqualTo(numericExpression, val);
                case "<=":
                    return cb.lessThanOrEqualTo(numericExpression, val);
                case "=":
                    return cb.equal(numericExpression, val);
                case ">":
                    return cb.greaterThan(numericExpression, val);
                case "<":
                    return cb.lessThan(numericExpression, val);
                default:
                    return null;
            }
        };
    }
}